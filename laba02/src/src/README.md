# Отчёт по лабораторной работе №02  
**Тема:** Основные структуры данных. Анализ и применение  
## Цель работы

Изучение и практическое применение базовых абстрактных структур данных (стек, очередь, дек, связный список). Оценка их асимптотических характеристик и производительности в Python. Формирование навыков выбора наиболее эффективной структуры данных для решения задач на основе анализа сложности операций.


## Теоретическая часть

**List (список)**  
Python-список реализован как динамический массив.  
- Доступ по индексу: **O(1)**  
- Добавление в конец: **O(1)** (амортизированное)  
- Вставка или удаление в начале или середине: **O(n)** из-за необходимости сдвига элементов  

**Linked List (связный список)**  
Каждый элемент (узел) содержит данные и ссылку на следующий.  
- Вставка в начало: **O(1)**  
- Удаление из начала: **O(1)**  
- Поиск/доступ по индексу: **O(n)**  

**Stack (стек)**  
Тип LIFO: последний пришёл — первый вышел.  
- Операции: push, pop, peek — все **O(1)**  
- Реализация через `list` или `deque`  

**Queue (очередь)**  
Тип FIFO: первый пришёл — первый ушёл.  
- enqueue (добавление) — **O(1)**  
- dequeue (удаление) — **O(1)** при использовании `collections.deque`  
- Список (`list`) неэффективен — `pop(0)` даёт **O(n)**  

**Deque (двусторонняя очередь)**  
Позволяет добавлять и удалять элементы с обеих сторон.  
- Все основные операции — **O(1)**  
- Эффективно реализован в Python через `collections.deque`  

## Практическая часть

### Задания

- Реализация класса `LinkedList` с ключевыми операциями  
- Анализ производительности операций в `list`, `deque` и `LinkedList`  
- Решение прикладных задач с выбором подходящих структур  

## Реализованные методы и задачи

### `linked_list.py`

- `insert_at_start(data)` — вставка в начало (**O(1)**)  
- `insert_at_end(data)` — вставка в конец (**O(n)**)  
- `delete_from_start()` — удаление из начала (**O(1)**)  
- `traversal()` — обход списка (**O(n)**)  

### `task_solutions.py`

- `check_brackets` — проверка сбалансированности скобок через стек (**O(n)**)  
- `simulate_print_queue` — имитация очереди печати через `deque` (**O(n)**)  
- `is_palindrome` — проверка палиндрома через двустороннюю очередь (**O(n)**)  


## Аппаратное и программное обеспечение

- **Устройство:** MacBook на базе Apple Silicon M4  
- **Операционная система:** macOS 14  
- **Оперативная память:** 16 GB  
- **Python:** версия 3.13.2  

## Результаты и выводы

- Эффективность операций подтверждена экспериментально:
  - `LinkedList.insert_at_start` и `deque.popleft()` работают за **O(1)**  
  - `list.insert(0)` и `list.pop(0)` требуют **O(n)**

- Для операций у начала структуры (вставка/удаление) **выгоднее использовать** `LinkedList` или `deque`.

- `list` остаётся оптимальным выбором для:
  - доступа по индексу (**O(1)**),
  - добавления в конец (**O(1)**)

- Влияние накладных расходов системы на измерения времени при малом количестве операций следует учитывать (временные "провалы" не обязательно означают ошибку в реализации).


## Ответы на контрольные вопросы

**1. Чем отличается список (list) от связного списка при вставке в начало и доступе по индексу?**  
- Доступ:  
  - `list`: **O(1)**  
  - `LinkedList`: **O(n)**  
- Вставка в начало:  
  - `list`: **O(n)** (требуется сдвиг)  
  - `LinkedList`: **O(1)** (изменение указателя)

**2. Принцип работы и примеры использования стека и очереди.**

- **Стек (LIFO)**:  
  Последний добавленный элемент удаляется первым.  
  Примеры:
  - Отмена последнего действия (undo)
  - Обход в глубину (DFS)

- **Очередь (FIFO)**:  
  Первый добавленный — первый удаляется.  
  Примеры:
  - Очередь задач на печать
  - Обработка запросов в веб-сервере

**3. Почему `list.pop(0)` — O(n), а `deque.popleft()` — O(1)?**  
- `list`: удаление первого элемента требует сдвига всех последующих  
- `deque`: удаление из начала не требует сдвига — реализовано через двусвязную структуру

**4. Какую структуру выбрать для системы отмены действий (undo)?**  
- **Стек (LIFO)** — идеально подходит, так как последнее действие нужно отменять первым

**5. Почему вставка 1000 элементов в начало быстрее в `LinkedList`, чем в `list`?**  
- `list.insert(0, x)` вызывает сдвиг — **O(n)** на каждую вставку  
- `LinkedList.insert_at_start` — простое изменение ссылки — **O(1)**  
- При 1000 вставках `list` работает примерно за **O(n·1000)**, `LinkedList` — **O(1000)**
